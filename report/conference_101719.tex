\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.

% Akash imports

% Colton imports

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\graphicspath{ {./images/} }


\begin{document}

\title{ECE 7600 Intro to Digital Signal Processing Final Project:
Card Detection and Identification using Image Processing
}

\author{\IEEEauthorblockN{Akash Fiech (201754892)}
\IEEEauthorblockA{\textit{MUN Computer Engineering} \\
% \textit{name of organization (of Aff.)}\\
St. John's, Canada \\
akashf@mun.ca}
\and
\IEEEauthorblockN{Colton Neal Smith (201819604)}
\IEEEauthorblockA{\textit{MUN Computer Engineering} \\
% \textit{name of organization (of Aff.)}\\
St. John's, Canada \\
csmith@mun.ca
}
}

\maketitle

\begin{abstract}
    This project was an implementation of a playing card identification system with image processing
    using OpenCV.
\end{abstract}

\begin{IEEEkeywords}
image processing, cards, OpenCV, C++
\end{IEEEkeywords}

\section{Introduction}
The goal of this project was to implement some form of well documented image processing procedure.
We chose to do playing card detection and classification for our project, this allowed us to use
many of the fundimentals that were learned in class over the semester. Some of the key fundamentals
being perspective shifting, edge detection, and intensity processing. The main resources on card
identification for this project was ``Poker Vision: Playing Cards and Chips Identification based on
Image Processing'' \cite{poker-vision}, and a Youtube video ``Playing Card Detection Using
OpenCV-Python on the Raspberry Pi 3 + PiCamera'' \cite{opencv-card-detection}. While these
resources were fantastic deviations were made to fit our use case and desired difficulty level.

\section{Planning}

\subsection{Desired Output and Interface}
For the final application we wanted an application that would run real-time from a 

\subsection{Image Processing Pipeline}
\begin{itemize}
\item Stage 1: Preprocessing
    \begin{itemize}
        \item Color to grayscale
        \item Gaussian Smoothing
        \item Linear Contrast Stretching
    \end{itemize}
\item Stage 2: Card Contour Detection
    \begin{itemize}
        \item Canny edge detection
        \item Contour Generation
        \item Trapezoid Filtering (Might not be necessary since we will be using a controlled
            environment)
    \end{itemize}
\item Stage 3: Card Extraction
\item Stage 4: Rank Extraction
\item Stage 5: Rank identification
\item Stage 6: Suit Extraction
\item Stage 7: Suit Identification
\end{itemize}

\section{Implementation}

\subsection{Language and Framework}
For this project the use of the OpenCV image processing framework with the C++ programming language
was chosen. This choice was made since OpenCV is the industry standard for image processing, it is
extremely well documented and there are multiple tutorials available. C++ was chosen because while
being the native implementation of OpenCV it is also more performant than Python and allows for
lower level optomisations when needed during the image processing program.

Along with OpenCV the OpenCV Graph API (G-API) was chosen for our image processing pipeline. Similar
to shader pipelines with game engine frameworks the pipeline allows for better modularity and as the
name implies pipelining of the process. This module of OpenCV is still in its early stages and has
some minor issues, but overall use of the G-API greatly improved development time than if without.

Finally the last library used was the cvui library, which is an open source graphical user interface
library using OpenCV. This was brought in so that buttons and sliders could be used when calibrating
the card indentifier and views of the intermediate stages could be seen (Figure \ref{fig:gui}). This
greatly improved development time as we could debug different parameters in real time.

\begin{figure}[htbp]
\centerline{\includegraphics{fig1.png}}
\caption{GUI for card identifier program using cvui Library.}
\label{fig:gui}
\end{figure}


\subsection{Final Implementation}

\subsubsection{Environmental Assuptions} % This seams to the same as issues
The final implementation made some assumptions on how the cards would be presented, these were as
follows:
\begin{itemize}
    \item The cards are placed on a darker uniform background, so the white background of the cards
        don't clash with the surface.
\end{itemize}


\subsubsection{Encountered Issues}
The key issues encountered while programming the application was the detection of the card border.
Once this preprocessing was done to the image and the edge detection was run, the contours were
generated. A lot of contours would be generated, then we would filter them by determining if they
were polygons, and also filter them based on heirachy as the polygons detected within a card were
inconsequential at this stage. This allowed us to get a nice contour of the card; using these
contours we could approximate the corners of the card and them use them for a perspective change so
that we could have a flat card of the same everytime to use our bounding boxes on the rank and type.

Once we got the contours of the card it is necessary to then perspective shift it to a known size so
that we can hardcode locations for the rank and suit. The corners of the card were estimated using
the contours, however the points need to then be mapped to the perspective shifted image in a manor
that provides the scaled image of a card with the suit and rank information at the top left corner.
The perspective shift introduced a tradeoff issue; account for all rotations at the cost of
development time. We chose a custom method where the center of the card was found and used as the
origin of a graph, and then assumed the corner point in Quadrant 2 to be top left, point in Quadrant
1 to be top right, and so on (Figure \ref{fig:graph}). Since we do not care if the card is upside
down this allows for about 180 deg of card position that will work with the model.

\begin{figure}[htbp]
\centerline{\includegraphics{graph-quadrants.png}}
\caption{Quadrents of a graph}
\label{fig:graph}
\end{figure}

% Since the rank and suit images (identifier images) were hardcoded from the scaled card image, there is deviation present
% in the identifier images the absolute difference for matching against the identifier template would
% also be inconsistent. Therefore further processing was done 

The output of the preprocessed rank and suit images (identifier images) were matched against a
template image of the rank and suit that was found online. Initially this provided extremely poor
matching; therefore, images were taken of all the necessary identifiers and then by hand cropped and
thresholded into a custom identifier image. This greatly improved performace for our card deck, with
the downside that it is only calibrated for a single deck of cards.

\section{Results}
The resulting application for detecting cards and their type works better than expected however
there are still limitations to it's use.

\section{Computational Performance}
The intial benchmark that we set for our programs computational performace was around 5 frames per
second (fps), this is the speed that we observed in other usable implementations
\cite{opencv-card-detection} (this was obviously running on a Raspberry Pi 3, therefore performace
is expected to be lower). Our implementations general speed was around 20 fps (With 1 card on
screen); this was better than expected. Even with a arguably inefficient gui library written using
Opencv (cvui), we were able to 

\subsection{Limitations}
These are the following limitations that were found with the current application:
\begin{itemize}
\item Calibrated to a specific card pack. Other card packs do not recieve the same amount of correct
        rank and suit estemates.
\item The entire card must be on the image being processed. If Even a tiny bit is cut off the
        detection will fail. This also holds true for overlapping cards; therefore, cards must not
        overlap each other (which is extremely common in card games).
\item The rotation of the card on the page must be within 45 deg from upright. The matching of the
        corners to the perspective transform is based of the position of the corner relative to the
        cards center point. Therefore an upside down card is fine due to the nature of the card
        descriptions on both top left corners. So there is about 180 deg discontinuous position
        where the detection will work.
\item Bright shining lights that reflect off the card can wash out key features that are used to
        detect the card, while still being readable to humans.
\end{itemize}

Probably place some example images here for when things don't work. Take as screen grabs from the
video demo

% \begin{figure}[htbp]
% \centerline{\includegraphics{fig1.png}}
% \caption{GUI for card identifier program using cvui Library.}
% \label{fig:gui}
% \end{figure}

\section{Future Improvements}
While we are happy with the state of our application we realize there is still place for
improvement. The potential improvements are mostly derived from the shortcomings in the
\ref{Limitations} section.

To handle full 360 degree rotation of the cards we could improve upon our corner detection by taking
into account the distance between points and then matching the card length and with, so that we
always receive the top corneres as being the shorter width of the card. This would allow the
perspective transform to always map the card so that the rank and suit info is in the top left
corner.

The appliation is currently calibrated for a specific card pack with a specific font for the rank
and suit identifiers. To improve the versitility of the program we could generate more reference
identifiers and then determine rank and suit based upon a statistical model. With a large enough
reference bank we could probably cover a very large range of usable cards.

While we were surprised by the speed of our application (running at around 20 fps), we could
definetly improve upon the speed. Currently the base CPU implementation for OpenCV is being used for
image processing; this could be changed to use the OpenCV CUDA or OpenCV backend. This would greatly
improve speed as the amount of parallel instructions running would drastically increase.

\section{Conclusions}
The implementation of playing card detection and identification using image processing and OpenCV
was a great learning experience. We were able to test our fundamental knowledge of image processing
and learn a bit beyond what we were taught in class. Overall we are happy with the outcome of our
application; we were able to relaibly detect almost all cards. There were still cases with specific
cards where the output would be consistently incorrect. Other than that the main issues with the
current implementation is that there are conditions such as cut off cards, overexposed lighting,
orientation, etc. that cause the identification of cards to fail. A couple strategies at mitegating
these issues have also been discussed along with potential to improve computational performance.

\section*{References}
\begin{thebibliography}{00}
\bibitem{poker-vision} P. Martins, L. P. Reis, and L Teofilo, ``Poker Vision: Playing Cards and
    Chips Identification based on Image Processing''.
\bibitem{opencv-card-detection} Youtube video here on card detection
\end{thebibliography}
\vspace{12pt}
\color{red}
IEEE conference templates contain guidance text for composing and formatting conference papers. Please ensure that all template text is removed from your conference paper prior to submission to the conference. Failure to remove the template text from your paper may result in your paper not being published.

\end{document}
